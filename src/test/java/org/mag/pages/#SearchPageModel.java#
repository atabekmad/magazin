package org.mag.pages;

import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.FindBys;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.ui.Select;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.mag.pages.SearchPageProduct;
import static org.junit.Assert.fail;
import static org.mag.pages.PageUtils.*;


public class SearchPageModel 
{
    private String url = "http://testmeagain.github.io/AngularBootstrapExample/#/login";
    private Select colorOptions;
    private List<WebElement> productContainers;
    //    private List<SearchPageProduct> products;
    private Map<String, SearchPageProduct> productsMap;

    @FindBy(name="colors")
    public WebElement colorDropDown;

    @FindBy(linkText="Log out")
    public WebElement logOutButton;

    @FindBy(partialLinkText="Cart:")
    public WebElement viewCart;

    
    public SearchPageModel(String email, String password) 
    {
	registerAccount(email,password);
	loginWithAccount(email,password);
	PageFactory.initElements(driver,this);
	try {    
	    // Instead of sleep we could wait explicitly for particular element but
	    // products may vary (html) and we don't know what exact element to wait for 
	    TimeUnit.MILLISECONDS.sleep(500);  
	} catch(InterruptedException e) {
	    e.toString();
	}
	this.colorOptions = new Select(colorDropDown);
	this.setProducts();
    }

    public void setProducts()
    {
	this.productContainers = driver.findElements(By.cssSelector("div.media-body.container"));
	productsMap= new HashMap<String, SearchPageProduct>();
	//	products = new ArrayList<SearchPageProduct>();

	for (WebElement element : productContainers) {
	    SearchPageProduct product = new SearchPageProduct(element);
	    productsMap.put(product.name, product);
	    //	    products.add(new SearchPageProduct(element));
	}

    }

    public void selectColor(String color)
    {

	colorOptions.selectByValue(color);
    }

    public boolean isLoginPageShown()
    {
	return (driver.getCurrentUrl().endsWith("/#/login"));
    }


    public void checkThatShownProductsHaveColorOf(String color)
    {
	int before=0;
	for (Map.Entry<String, SearchPageProduct> entry : productsMap.entrySet()) {
	    if (entry.getValue().color == color) {
		    before++;
		}
	}

	int after=0;
	this.setProducts();
	for (Map.Entry<String, SearchPageProduct> entry : productsMap.entrySet()) {
	    if (entry.getValue().color == color) {
		    after++;
	    }	
	}

	if (after!=before) {
	    fail("Number of products before selecting a color doesn't match number of shown products after");
	}
    }

    public void makeOrders(String[] productOrders)
    {

	for (String order : productOrders) {
 	    productsMap.get(order).orderButton.click();
	}
	    
    }

    public String[] getCartItems()
    {
	clickOn(viewCart);

	try {    
	    // Instead of sleep we could wait explicitly for particular element but
	    // products may vary (html) and we don't know what exact element to wait for 
	    TimeUnit.MILLISECONDS.sleep(1000);  
	} catch(InterruptedException e) {
	    e.toString();
	}
	// WebElement unorderedList = (new WebDriverWait(driver, 10))
	//     .until(ExpectedConditions.presenceOfElementLocated(By.cssSelector("ul.ng-scope")));
	
	WebElement unorderedList = driver.findElement(By.cssSelector("div.modal-body.ng-scope"));
	System.out.println("I've found UL list");
	System.out.println(unorderedList.getText());
	List<WebElement> items = unorderedList.findElements(By.tagName("li"));
	int size = items.size();
	String[] result = new String[size];

	for (int i=0; i<size; i++) {
	    result[i] = items.get(i).getText();
	}
	driver.findElement(By.linkText("OK")).click();
    	return result;
    }
}
